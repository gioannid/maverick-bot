package johnidis.maverick.exploitbot;

import java.util.Locale;

import com.biotools.meerkat.GameInfo;

import johnidis.maverick.Holdem;
import johnidis.maverick.Agent.Capabilities;
import johnidis.maverick.modelling.adapters.*;
import johnidis.maverick.modelling.data.MLData;
import johnidis.maverick.modelling.modellers.Modeller;
import johnidis.utils.AbortException;
import data.ArrayTools;
import data.Bucket;
import data.GameState;
import ringclient.ClientRingDynamics;
import simulation.real.SimulationGame;

public class ExploitGame extends SimulationGame {
	
	private static final int			HAND_BIAS		= 1;
	private static final double[] 		UTILITY_HAND 	= new double[BNGameAdapter.SET_HAND_FINAL.length];
	private static final Capabilities 	CAPABILITIES	= new Capabilities (2, Holdem.MAX_PLAYERS, 
			Capabilities.FIXED_LIMIT + Capabilities.BEHAVIORAL_MODELLING);

	public GameAdapter gameSnapshot;
//	public GameAdapter handGS;
	
	static {
		for (int h = 0; h < BNGameAdapter.SET_HAND_FINAL.length; h++) {
			int hand = ((BNGameAdapter.PostflopBucket) (BNGameAdapter.SET_HAND_FINAL[h].entity)).hand;
			int kicker = ((BNGameAdapter.PostflopBucket) (BNGameAdapter.SET_HAND_FINAL[h].entity)).kicker;
			UTILITY_HAND[h] = ((hand + 1) << 12) + ((double) kicker / 3) * (1 << 12);
		}
	}
	
	static public double random (double[] probabilities, double[] utility) {
		int samples = probabilities.length;
		double random = Math.random();
		double cdf = 0;
		for (int p = 0; p < samples; p++) {
			double probOffset = cdf;
			cdf += probabilities[p >= HAND_BIAS ? p - HAND_BIAS : 0];
			if (random < cdf) {
				double probPercentage = (random - probOffset) / probabilities[p >= HAND_BIAS ? p - HAND_BIAS : 0];
				if (utility == null)
					return (p + probPercentage) / samples;
				else {
					double utilityPminus1 = (p == 0) ? 0 : utility[p-1];
					return utilityPminus1 + (utility[p] - utilityPminus1) * probPercentage;
				}
			}
		}
		if (utility == null)
			return 1;
		else
			return utility[utility.length-1];
	}
	
	private int estimateHR() throws AbortException {
		String player = crd.botNames[actualSeat];
		MLData estimation = Holdem.modeller.estimate(player, Holdem.BEHAVIORAL_MODEL_HAND, gameSnapshot, true);
		if (debugHole != null) {
			Object[] estperc = new Integer[12];
			for (int p = 0; p < 12; p++)
				estperc[p] = (int) (estimation.getData(p) * 100);
			debugHole[actualSeat] += String.format(Locale.US, "(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)", estperc);
		}
		if (estimation == null) {
			if (DEBUG)
				if ((DEBUG_ROUND == crd.handNumber) || (DEBUG_ROUND == -1)) {
					debug("  "+Holdem.modeller.open(player).toString(), true);
					debug("    BN-> null", true);
				}
			throw new AbortException ("Could not predict HR for "+player);
		}
		int rank = (int) random (estimation.getData(), UTILITY_HAND);
		if (DEBUG)
			if ((DEBUG_ROUND == crd.handNumber) || (DEBUG_ROUND == -1)) {
				debug("  "+Holdem.modeller.open(player).toString(), true);
				debug("    BN->"+estimation+", randomRank = "+rank, true);
			}
		return rank;
	}
	
	
	public ExploitGame() {
		super ();
	}

	private ExploitGame(ClientRingDynamics crd, Holdem holdem) {
		super (crd, holdem);
		gameSnapshot = Holdem.newActionAdapter(holdemSession.gameSnapshot, this);
//		handGS = Holdem.newHandAdapter(holdemSession.handGameSnapshot, this);
	}

	private ExploitGame(ExploitGame game, Holdem holdem) {
		super (game, holdem);
		gameSnapshot = Holdem.newActionAdapter(game.gameSnapshot, this);
//		handGS = Holdem.newHandAdapter(game.handGS, this);
		if (((round == GameState.FLOP.ordinal()) && (board[0] == null))
				|| ((((round == GameState.TURN.ordinal()) || ((round == GameState.RIVER.ordinal()))) && (board[round] == null)))
				|| (round == GameState.SHOWDOWN.ordinal()))
			((BNGameAdapter) gameSnapshot).originalRoundIndex = round - 2;
		generateNextRound();
	}

	
	@Override
	public SimulationGame newInstance(SimulationGame game, Holdem holdemSession) {
		return new ExploitGame((ExploitGame) game, holdemSession);
	}

	@Override
	public SimulationGame newInstance(ClientRingDynamics crd, GameInfo gameInfo, Holdem holdemSession) throws AbortException {
		if (crd.roundIndex == 0)
			throw new AbortException ("ExploitBot does not support preflop play");
		return new ExploitGame(crd, holdemSession);
	}
	
	@Override
	protected void generateTurnRiver() {
		super.generateTurnRiver();
		gameSnapshot.onRoundStart(this);
//		handGS.onRoundStart(this);
	}

	@Override
	protected void generateFlop() {
		super.generateFlop();
		gameSnapshot.onRoundStart(this);
//		handGS.onRoundStart(this);
	}

	@Override
	protected void raiseAction() {
//		handGS.onAction(this, 'r');
		gameSnapshot.onAction(this, 'r');
		super.raiseAction();
	}

	@Override
	protected void callAction() {
//		handGS.onAction(this, (getAmountToCall(actualSeat) == 0) ? 'k' : 'c');
		gameSnapshot.onAction(this, (getAmountToCall(actualSeat) == 0) ? 'k' : 'c');
		super.callAction();
	}

	@Override
	protected void foldAction() {
//		handGS.onAction(this, 'f');
		gameSnapshot.onAction(this, 'f');
		super.foldAction();
	}
	
	@Override
	protected MLData estimateDecisionProbabilities() throws AbortException {
		gameSnapshot.update(this);
		if (DEBUG) {
			double[] in = new double[BNGameAdapter.InputData.FIELDS];
			gameSnapshot.collectInputs(BNGameAdapter.ACTION_NA, in);
			debugRound(ArrayTools.deepToString(BNGameAdapter.InputData.values(), in)+"->");
			if ((DEBUG_ROUND == crd.handNumber) || (DEBUG_ROUND == -1))
				debug(gameSnapshot.toString(), true);
		}
		MLData estimation = Holdem.histogramActions.getPoints(crd.botNames[actualSeat], gameSnapshot,
				prediction -> {
					if (DEBUG)
						debugRound(String.format(Locale.US, "(%d,%d,%d)->", (int) (prediction.getData(0)*100),
								(int) (prediction.getData(1)*100), (int) (prediction.getData(2)*100)));
					return prediction;
				});
/*		MLData estimation = Holdem.modeller.estimate(crd.botNames[actualSeat], 
				Holdem.BEHAVIORAL_MODEL_ACTION,	gameSnapshot, true);*/
		if (estimation != null) {
			if (DEBUG)
				debugRound(String.format(Locale.US, "(%d,%d,%d) ", (int) (estimation.getData(0)*100),
						(int) (estimation.getData(1)*100), (int) (estimation.getData(2)*100)));
			Modeller.normalize(estimation, -1);
		}
		return estimation;
	}

	@Override
	protected int estimatedHandRank (int player) throws AbortException {
		int rank;
		showdowns[player]++;
		if (player == ownSeat) {
			int[] hand = GameAdapter.handToEvaluate(crd.hole[ownSeat], board);
			rank = Bucket.evaluator.handRank(hand);
		} else {
			actualSeat = player;
			gameSnapshot.update(this);
			if (DEBUG)
				if ((DEBUG_ROUND == crd.handNumber) || (DEBUG_ROUND == -1))
					debug(gameSnapshot.toString(), true);
			rank = estimateHR();
		}
		if (debugHole != null)
			debugHole[player] += "["+rank+"]";
		sumShowdownRanks[player] += rank;
		return rank;
	}

	@Override
	public void setDebug(boolean debug) {
		gameSnapshot.report = debug;
//		handGS.report = debug;
	}

	@Override
	public Capabilities capabilities() {
		return CAPABILITIES;
	}

	@Override
	public void shutdown() {
		;
	}
	
}
