package johnidis.maverick.exploitbot;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Vector;

import com.biotools.meerkat.GameInfo;

import johnidis.maverick.Holdem;
import johnidis.maverick.Iface;
import johnidis.maverick.Preferences;
import johnidis.utils.AbortException;
import data.Action;
import data.Constants;
import ringclient.ClientRingDynamics;
import simulation.datastructure.DecisionArc;
import simulation.datastructure.LeafNode;
import simulation.interfaces.IArc;
import simulation.interfaces.INode;
import simulation.real.SimulationGame;
import simulation.real.datastructure.PlayerNode;
import simulation.real.datastructure.PlayerState;

public class Simulator {
	
	private static final int MIN_DECISION_SAMPLES = 80;
	
	private int[] showdowns;
	private long[] sumShowdownRanks;
	private volatile boolean aborted;
	private final Holdem holdemSession;
	

	private class SimulationWorker implements Runnable {
		
		private FileWriter debugFile = null;
	/** deck;board;round1;round2;round3;round4;winners;value;handrank0;... */

		private final INode root;
		private final INode startNode;
		private final SimulationGame game;
		private volatile Thread worker;
		private volatile String name;
		private int[/*player*/][/*nextAction*/] nextActions;
		

		private class PathSimulator {
			
			private INode root;
			private SimulationGame game;
	
			public PathSimulator(INode root, SimulationGame game) {
				this.game = game;
				this.root = root;
			}

			public void simulatePath(INode node) throws AbortException {
				int count = 0;
				int oldRound = game.round;
				while (!(node instanceof LeafNode) && count < 150) {
					if (SimulationGame.DEBUG) {
						if ((SimulationGame.DEBUG_ROUND == game.crd.handNumber) || (SimulationGame.DEBUG_ROUND == -1))
							SimulationGame.debug("...." + game.debugHole[game.actualSeat], true);
					}
					if (node instanceof PlayerNode) {
						DecisionArc arc = game.getDecision((PlayerNode) node);
						node = arc.getChild();
					} 
					if (oldRound != game.round) {
						if (SimulationGame.DEBUG) {
							if ((SimulationGame.DEBUG_ROUND == game.crd.handNumber) || (SimulationGame.DEBUG_ROUND == -1)) {
								SimulationGame.debug("  inPot = [", false);
								for (int i=0; i < game.crd.numPlayers; i++)
									SimulationGame.debug(String.valueOf(game.playerStates[i].getAmountIn())+" ", false);
								SimulationGame.debug("]", true);
								SimulationGame.debug(" </NewRound>", true);
								SimulationGame.debug(" <NewRound round="+game.round+">", true);
								SimulationGame.debug("  " + game.toString(), true);
							}
						}
						oldRound = game.round;
					}
					count++;
				}
				if (node instanceof LeafNode) {
					LeafNode leaf = (LeafNode) node;
					backTrace(node.getParentArc(), leaf.getValue());
				}
			}

			private void backTrace(IArc arc, double value) {
				if (root != null && arc!=null) {
					INode parent = arc.getParent();
					while (parent!=null && !parent.equals(root)) {
						arc.addValue(value);
						arc = parent.getParentArc();
						parent = arc.getParent();
					}
					arc.addValue(value);
				}
				if (SimulationGame.DEBUG) {
					game.debugValue = Iface.FORMATTER.format(value);
					if ((SimulationGame.DEBUG_ROUND == game.crd.handNumber) || (SimulationGame.DEBUG_ROUND == -1)) {
						SimulationGame.debug("  Value: "+value, true);
						SimulationGame.debug(" </NewRound>", true);
						SimulationGame.debug("</Game>", true);
					}
				}
				synchronized (showdowns) {
					for (int p = 0; p < game.crd.numPlayers; p++) {
						showdowns[p] += game.showdowns[p];
						sumShowdownRanks[p] += game.sumShowdownRanks[p];
						for (int a = 1; a <= 3; a++)
							if (game.nextAction[p] == a)
								nextActions[p][a-1]++;
					}
				}
			}
			
		}

		
		public SimulationWorker(INode root, SimulationGame game, INode child, String name) {
			this.root = root;
			this.game = game;
			this.worker = new Thread(this, name);
			this.startNode = child;
			this.name = name;
			nextActions = new int[crd.numPlayers][3];
		}
		
		public void start() {
			worker.start();
		}
		
		@SuppressWarnings("null")
		public void run() {
			game.setDebug(false);
			if (SimulationGame.DEBUG) {
				synchronized (this) {
					int id;
					File file;
					boolean debug = ((SimulationGame.DEBUG_ROUND == game.crd.handNumber) || 
							(SimulationGame.DEBUG_ROUND == -1)) &&	(name.equals(SimulationGame.DEBUG_SIM_THREAD+"1"));
					game.setDebug(debug);
					do {
						id = getDebugFileId ();
						file = new File ("debug\\simulation_"+id+"_"+name+".csv");
					} while (file.exists());
					if ((SimulationGame.DEBUG_ROUND == game.crd.handNumber) || (SimulationGame.DEBUG_ROUND == -1))
						SimulationGame.debug("<Simulation id=\"" + Thread.currentThread().getName() + "\">", true);
					try {
						debugFile = new FileWriter (file);
						holdemSession.println ("Writing "+file.getName());
					} catch (IOException e) {
						holdemSession.println("Opening file "+debugFile.toString()+" failed!");
					}
				}
			}
			SimulationGame g = null;
			try {
				while (worker != null) {
					g = gameFactory.newInstance (game, holdemSession);
					PathSimulator ps = new PathSimulator (root, g);
					if ((startNode instanceof LeafNode) && 
							(((LeafNode) startNode).getValue() == LeafNode.VALUE_PENDING)) {
						((LeafNode) startNode).setValue(g.actualLeafNode().getValue());
						ps.simulatePath(startNode);
						((LeafNode) startNode).setValue(LeafNode.VALUE_PENDING);
					} else
						ps.simulatePath(startNode);
					if (SimulationGame.DEBUG) {
						StringBuilder line = new StringBuilder(g.debugDeck).append(';').append(g.toString());
						for (int r=0; r<4; r++)
							line.append(';').append(g.debugRound[r]);
						line.append(';').append(g.debugWinners).append(';').append(g.debugValue);
						for (int p=0; p<g.crd.numPlayers; p++)
							line.append(';').append(g.debugHole[p]);
						line.append(Iface.LINE_SEPARATOR);
						try {
							debugFile.write(line.toString());
						} catch (IOException e) {
							;
						}
					}
					g.shutdown();
					g = null;
				}
				if (SimulationGame.DEBUG)
					if ((SimulationGame.DEBUG_ROUND == game.crd.handNumber) || (SimulationGame.DEBUG_ROUND == -1))
						SimulationGame.debug("</Simulation>", true);
				
				String thread = Thread.currentThread().getName();
				if (thread.endsWith("1")) {
					int p = crd.seatTaken;
					do {
						p = crd.getNextActiveSeat(p);
						holdemSession.print(thread+" "+crd.botNames[p]+" action prediction: ");
						int total = 0;
						for (Action act : Action.values())
							total += nextActions[p][act.ordinal()];
						if (total > 0)
							for (Action act : Action.values())
								holdemSession.print(act+"="+nextActions[p][act.ordinal()]+" ("+
										nextActions[p][act.ordinal()]*100/total+"%) ");
						else
							holdemSession.print("no data");
						holdemSession.println();
					} while ((p != crd.seatTaken) && (crd.active[crd.seatTaken]));
				}
			} catch (AbortException e) {
				holdemSession.err("Simulator failed: "+e.getMessage());
				aborted = true;
			} catch (Exception e) {
				e.printStackTrace();
				aborted = true;
			} finally {
				if (g != null)
					g.shutdown();
				name = null;
				if (debugFile != null)
					try {
						debugFile.close();
					} catch (IOException e) {
						holdemSession.println("Closing file "+debugFile.toString()+" failed!");
					}
			}
		}
		
		public void stopWork() {
			this.worker = null;
			while (name != null) {
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					name = null;
				}
			}
		}
		
	}

	private static final long stop_loss_percentage;
	private static volatile int debugFileId = 0;
	
	private INode root;
	private ClientRingDynamics crd;
	private Vector<SimulationWorker> workerThreads = new Vector<SimulationWorker>();
	private volatile boolean started;
	private long stop;
	private long start;
	private final SimulationGame gameFactory;

	static {
		if (Preferences.SIM_STOPLOSS.getValue() != null)
			stop_loss_percentage = Preferences.SIM_STOPLOSS.getValue();
		else
			stop_loss_percentage = 0;
	}
	
	public static synchronized int getDebugFileId () {
		return debugFileId++;
	}


	public Simulator(Holdem holdem, SimulationGame game) {
		holdemSession = holdem;
		gameFactory = game;
		holdemSession.println("Stop-loss value at "+stop_loss_percentage+"%");
		holdemSession.println("Simbot using "+gameFactory.getClass().getSimpleName()+" simulator");
	}


	private INode getRootNode() {
		PlayerNode root = new PlayerNode(new PlayerState(crd, crd.seatTaken), SimulationGame.nodeId.getAndIncrement());
		root.player.setName("root");
		return root;
	}
	
	private IArc addWorkingThread (int decision, GameInfo gameInfo, String id) throws AbortException {
		SimulationGame game = gameFactory.newInstance(crd, gameInfo, holdemSession);
		DecisionArc arc = game.getDecision((PlayerNode) root, decision);
		SimulationWorker sw = new SimulationWorker(root, game, arc.getChild(), id);
		sw.start();
		workerThreads.add(sw);
		return arc;
	}
	
	public Action getDecision() {
		if (started) {
			synchronized (workerThreads) {
				while (workerThreads.size() > 0) {
					SimulationWorker simW = workerThreads.remove(0);
					simW.stopWork();
				}
			}
			started = false;
			if (aborted) {
				return null;
			}
			this.stop = System.currentTimeMillis();
			Vector<IArc> childArcs = root.getChildArcs();
			root = null;
			int simCount = 0;
			int actualDecision = Action.FOLD.toInt();
			holdemSession.println("Decisions: (Game:" + crd.handNumber + ")");
			double actualValue = Double.NEGATIVE_INFINITY;
			int[] value = new int[3];
			int[] samples = new int[3];
			for (IArc child : childArcs) {
				int decision = child.getDecision().toInt();
				simCount += child.getSimulationCount();
				holdemSession.println("Dec: " + child.getDecision() + " Value: "
						+ child.getValue() + " WinRatio: " + child.getWinRatio() + " SimCount: " + child.getSimulationCount());
				value[decision] += child.getCumulatedValue();
				samples[decision] += child.getSimulationCount();
			}
			
			try {
				synchronized (showdowns) {
					int ownShows = showdowns[crd.seatTaken];
					if (ownShows > 0) {
						long ownRank = sumShowdownRanks[crd.seatTaken] / ownShows; 
						for (int p = 0; p < crd.numPlayers; p++) {
							int s = showdowns[p];
							if (s > 0) {
								long r = sumShowdownRanks[p] / s;
								holdemSession.println(crd.botNames[p]+" reached showdown "+s+" times, mean rank = "+r);
								if ((r * stop_loss_percentage / 100 > ownRank) && (crd.roundIndex > 0)) {
									holdemSession.println(crd.botNames[p]+" rank outclasses "+crd.botNames[crd.seatTaken]+
											" rank ("+ownRank+"), folding hand for stop-loss.");
									if (crd.getAmountToCall(crd.seatTaken) == 0) {
										return Action.CALL;
									} else return Action.FOLD;
								}
							}
						}
					}
				}
			} catch (NullPointerException e) {
				System.err.println("Simulator instance still running, aborting new instance");
				return null;
			}
			
			for (int d = 0; d < 3; d++) {
				if ((d > 0) && (samples[d] < MIN_DECISION_SAMPLES)) {
					holdemSession.println("Dec: " + d + ": Too few samples ("+samples[d]+"), aborting");
					return null;
				}
				double tempValue = (double) value[d] / (double) samples[d];
				holdemSession.println("Dec: " + d + " Value: "	+ tempValue);
				if (tempValue > actualValue) {
					actualValue = tempValue;
					actualDecision = d;
				}
			}
			holdemSession.println("SimCount: " + simCount + " Time (in ms): " + (stop - start));
			return (actualDecision == Action.RAISE.toInt() ? Action.RAISE :
					crd.getAmountToCall(crd.seatTaken) == 0 ? Action.CALL :
					actualDecision == Action.CALL.toInt() ? Action.CALL :
					Action.FOLD);
		}
		return Action.FOLD;
	}

	public void startSimulation(ClientRingDynamics crd, GameInfo gameInfo) throws AbortException {
		this.start = System.currentTimeMillis();
		if ((showdowns != null) || (sumShowdownRanks != null))
			throw new AbortException ("Simulator.startSimulation(): nested call");
		showdowns = new int[crd.numPlayers];
		sumShowdownRanks = new long[crd.numPlayers];
		aborted = false;
		synchronized (workerThreads) {
			while (workerThreads.size() > 0) {
				SimulationWorker simW = workerThreads.remove(0);
				simW.stopWork();
			}
			this.crd = crd;
			int id = 0;
			this.root = getRootNode();
			this.started = true;
			SimulationGame fold = gameFactory.newInstance(crd, gameInfo, holdemSession);
			DecisionArc foldArc = fold.getDecision((PlayerNode) root, Action.FOLD.toInt());
			foldArc.addValue(((LeafNode) foldArc.getChild()).getValue());
			do {
				id++;
				IArc raiseArc = addWorkingThread (Action.RAISE.toInt(), gameInfo, "raise"+id);
				if (raiseArc.getDecision() == Action.RAISE) {
					addWorkingThread (Action.CALL.toInt(), gameInfo, "call"+id);
				}
			} while (id*2 < Constants.AVAILABLE_CPUS);
		}
	}

	public void killTree() {
		if (started) {
			synchronized (workerThreads) {
				while (workerThreads.size() > 0) {
					SimulationWorker simW = workerThreads.remove(0);
					simW.stopWork();
				}
			}
			started = false;
		}
		showdowns = null;
		sumShowdownRanks = null;
		Runtime.getRuntime().gc();
	}
	
}
