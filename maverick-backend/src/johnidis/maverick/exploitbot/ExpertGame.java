package johnidis.maverick.exploitbot;

import java.util.Arrays;

import poker.MaverickGameInfo;

import com.biotools.meerkat.Action;
import com.biotools.meerkat.Card;
import com.biotools.meerkat.GameInfo;
import com.biotools.meerkat.Hand;

import data.Bucket;
import data.CardGenerator;
import data.GameState;
import johnidis.maverick.Holdem;
import johnidis.maverick.Preferences;
import johnidis.maverick.Agent.Capabilities;
import johnidis.maverick.modelling.adapters.GameAdapter;
import johnidis.maverick.modelling.data.MLData;
import johnidis.maverick.modelling.modellers.ExpertModeller;
import johnidis.maverick.modelling.modellers.Modeller;
import johnidis.maverick.modelling.models.ExpertModel;
import johnidis.maverick.modelling.models.HistogramModel;
import johnidis.maverick.modelling.player.ExpertEstimator;
import johnidis.maverick.modelling.DecisionBot;
import johnidis.utils.AbortException;
import ringclient.ClientRingDynamics;
import simulation.datastructure.LeafNode;
import simulation.real.SimulationGame;

public class ExpertGame extends SimulationGame {
	
	public static ExpertModeller modeller;
	
	private static double fearFactor;

	private final MaverickGameInfo rootGameInfo;
	private final Hand[] meerkatHole;
	private final ca.ualberta.cs.poker.free.dynamics.Card[][] uoaHole;
	private DecisionBot bot = null;
	
	private static final Capabilities CAPABILITIES = new Capabilities (2, Holdem.MAX_PLAYERS, 
			Capabilities.FIXED_LIMIT + Capabilities.EXPERT_MODELLING);
	
	static {
		if (Preferences.SIM_FEARFACTOR.getValue() != null)
			fearFactor = (double) Preferences.SIM_FEARFACTOR.getValue() / 100;
		else
			fearFactor = 0.6;
		System.out.println("SimExpertBot fear factor at "+fearFactor);
	}
	
	public ExpertGame() {
		super();
		modeller.startTrainer(new ExpertEstimator(modeller));
		rootGameInfo = null;
		uoaHole = null;
		meerkatHole = null;
	}

	private ExpertGame(ClientRingDynamics crd, MaverickGameInfo gameInfo, Holdem holdem) {
		super (crd, holdem);
		rootGameInfo = new MaverickGameInfo();
		rootGameInfo.A(gameInfo);
		uoaHole = null;
		meerkatHole = null;
	}

	private ExpertGame(ExpertGame game, Holdem holdem) throws AbortException {
		super (game, holdem);
		rootGameInfo = game.rootGameInfo;
		bot = new DecisionBot(rootGameInfo, false);
		uoaHole = new ca.ualberta.cs.poker.free.dynamics.Card[crd.numPlayers][];
		meerkatHole = new Hand[crd.numPlayers];
		for (int p = 0; p < crd.numPlayers; p++) {
			meerkatHole[p] = new Hand();
			if (crd.active[p]) {
				if (p == ownSeat) {
					uoaHole[p] = crd.hole[ownSeat];
					meerkatHole[p].addCard(CardGenerator.index(uoaHole[p][0]));
					meerkatHole[p].addCard(CardGenerator.index(uoaHole[p][1]));
				} else {
					Card[] hole = (modeller).open(crd.botNames[p]).randomHole(rootGameInfo); 
					if (hole == null)
						throw new RuntimeException ("Hole selection failed");
					meerkatHole[p].addCard(hole[0]);
					meerkatHole[p].addCard(hole[1]);
					uoaHole[p] = new ca.ualberta.cs.poker.free.dynamics.Card[] {
							CardGenerator.getCard(hole[0]), CardGenerator.getCard(hole[1])};
				}
				if (debugHole != null)
					debugHole[p] += Arrays.deepToString(uoaHole[p]);
			}
		}
		generateNextRound();
	}

	
	@Override
	public SimulationGame newInstance(SimulationGame game, Holdem holdemSession) throws AbortException {
		return new ExpertGame((ExpertGame) game, holdemSession);
	}

	@Override
	public SimulationGame newInstance(ClientRingDynamics crd, GameInfo gameInfo, Holdem holdemSession) throws AbortException {
		if (crd.roundIndex == 0)
			throw new AbortException ("SimExpertBot does not support preflop play");
		return new ExpertGame(crd, (MaverickGameInfo) gameInfo, holdemSession);
	}

	@Override
	public void setDebug(boolean debug) {
		;
	}

	@Override
	protected void generateTurnRiver() {
		super.generateTurnRiver();
		if (round == GameState.TURN.ordinal())
			bot.turn(com.biotools.meerkat.Card.get(CardGenerator.index(board[3])));
		else
			bot.river(com.biotools.meerkat.Card.get(CardGenerator.index(board[4])));
	}

	@Override
	protected void generateFlop() {
		super.generateFlop();
		bot.flop(com.biotools.meerkat.Card.get(CardGenerator.index(board[0])),
				com.biotools.meerkat.Card.get(CardGenerator.index(board[1])), 
				com.biotools.meerkat.Card.get(CardGenerator.index(board[2])));
	}

	@Override
	protected void raiseAction() {
		super.raiseAction();
		if (bot != null)
			bot.raise();
		else
			rootGameInfo.raise();
	}

	@Override
	protected void callAction() {
		super.callAction();
		if (bot != null)
			bot.call();
		else
			rootGameInfo.call();
	}

	@Override
	protected void foldAction() {
		super.foldAction();
		if (bot != null)
			bot.fold();
		else
			rootGameInfo.fold();
	}
	
	@Override
	protected MLData estimateDecisionProbabilities() throws AbortException {
		Action action = bot.getAction(GameAdapter.seatToPlayer(bot.getGameInfo(), actualSeat), 
				Card.get(meerkatHole[actualSeat].getCardIndex(1)), Card.get(meerkatHole[actualSeat].getCardIndex(2)));
		if (DEBUG)
			if ((DEBUG_ROUND == crd.handNumber) || (DEBUG_ROUND == -1))
				debug("  "+action+" <= "+bot.toString(), true);
		MLData estimation = modeller.open(crd.botNames[actualSeat]).estimate(
				ExpertModel.Action, bot.getGameInfo().getStage() - 1, GameAdapter.getAction(action));
		int mostProbable = HistogramModel.indexMostProbable(estimation);
		for (int i = 0; i < estimation.size(); i++)
			if (i == mostProbable)
				estimation.setData(i, estimation.getData(i) * (1 + fearFactor));
			else
				estimation.setData(i, estimation.getData(i) * (1 - fearFactor));
		Modeller.normalize(estimation, -1);
		return estimation;
	}

	@Override
	protected int estimatedHandRank(int player) {
		if (uoaHole == null)
			return LeafNode.VALUE_PENDING;
		int rank = Bucket.evaluator.handRank(GameAdapter.handToEvaluate(uoaHole[player], board));
		if (debugHole != null)
			debugHole[player] += rank;
		showdowns[player]++;
		sumShowdownRanks[player] += rank;
		return rank;
	}

	@Override
	public Capabilities capabilities() {
		return CAPABILITIES;
	}

	@Override
	public void shutdown() {
		bot.shutdown();
		bot = null;
	}

}
