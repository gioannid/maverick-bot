package johnidis.maverick;import java.io.*;import java.lang.ref.WeakReference;import java.net.*;import java.util.*;import johnidis.maverick.Agent.Capabilities;import johnidis.maverick.exploitbot.ExpertGame;import johnidis.maverick.exploitbot.ExploitGame;import johnidis.maverick.modelling.*;import johnidis.maverick.modelling.adapters.*;import johnidis.maverick.modelling.modellers.ExpertModeller;import johnidis.maverick.modelling.models.ExpertModel;import johnidis.utils.AbortException;import johnidis.utils.collection.LevenshteinMap;//import bots.mctsbot.ai.bots.bot.gametree.mcts.MCTSMeerkatBot;import com.biotools.meerkat.Action;import com.biotools.meerkat.Hand;import data.Bucket;import poker.*;import poker.util.*;public class BotServer implements Runnable {		public static final String		VERSION				= "MAVERICK_1.22/150322";	private static final boolean	DEBUG				= false;		public static enum Bots {		FELLOMEN2 ("A HU, FL e-Nash equilibrium agent"),		POKIBOT ("A FL agent capable of modelling its opponents"),		EXPLOITBOT ("A FL exploitative Monte-Carlo agent based on behavioral modelling"),		SIMEXPERTBOT ("A FL exploitative Monte-Carlo agent based on expert modelling"),//		MCTSBOT ("A FL/NL agent doing MCTS to decide upon its actions"),		JAGBOT ("A FL agent playing ABC poker");				public static final int COUNT = values().length;				public final String description;				private Bots (String d) {			description = d;		}	}		public static final String USAGE =	/*       12345678901234567890123456789012345678901234567890123456789012345678901234567890 */		"usage: maverick [-test <seats> <rounds> <seed> [-testopp <seat> <kind>]... ]" + Iface.LINE_SEPARATOR +		"                [-rake <filename>] [-hh <filename> <path>] [-p <key>=<value>]..."+ Iface.LINE_SEPARATOR +		"                <port> <bot>... [<street>=<bot>]..." + Iface.LINE_SEPARATOR +		"       [-test]    initiates a test poker session" + Iface.LINE_SEPARATOR +		"       [-testopp] defines an opponent for the test session out of the following" + Iface.LINE_SEPARATOR +		"                  "+TestClient.ALWAYS_CALL_OPPONENT+": always-call bot" + Iface.LINE_SEPARATOR +		"                  "+TestClient.ALWAYS_RAISE_OPPONENT+": always-raise bot" + Iface.LINE_SEPARATOR +		"                  "+TestClient.RANDOM_ACTION_OPPONENT+": random-action bot" + Iface.LINE_SEPARATOR +		"                  ip:port: remote BotServer session" + Iface.LINE_SEPARATOR +		"       [-rake]    specifies the file containing rake ratios" + Iface.LINE_SEPARATOR +		"       [-hh]      specifies the format file and path to handhistory file(s)" + Iface.LINE_SEPARATOR +		"       [-p]       specifies a bot-specific parameter" + Iface.LINE_SEPARATOR +		"       <port>     the IP port server is listening to" + Iface.LINE_SEPARATOR +		"       <bot>      a list comprised of any of the below agents:" + Iface.LINE_SEPARATOR +		"       <street>   agent to handle specific street";	public static final int		ERROR_SERVER_IO						= -1;	public static final int		ERROR_MANDATORY_ARGUMENTS_MISSING	= -2;	public static final int		ERROR_UNKNOWN_ARGUMENT				= -3;	public static final int		ERROR_OPTIONAL_ARGUMENTS_MISSING	= -4;	public static final int		ERROR_INVALID_MIX_OF_ARGUMENTS		= -5;	public static final int		ERROR_WRONG_ARGUMENT_FORMAT			= -6;	public static final int		ERROR_UNKNOWN_PARAMETER				= -7;		private static final int	MOVING_AVERAGE_PERIOD				= 10;	private static final float	SUCCESS_WEIGHT_FACTOR				= 1.0F;	private static final int	DECISION_FOLD						= 0;	private static final int	DECISION_CALL						= 1;	private static final int	DECISION_RAISE						= 2;	private static final int 	MODEL_PERSISTENCE_PERIOD 			= 100;		public static final char	CENT								= (char) 162;	public static final char	EURO								= (char) 128;	public static final String	CURRENCY_CHARS						= "0123456789,.$"+EURO+CENT;		public static final String	INPUT_PREFIX						= (ExploitGame.DEBUG ? "((( " : "<<< ");	public static final String	OUTPUT_PREFIX						= (ExploitGame.DEBUG ? "))) " : ">>> ");		static final Set<BotServer> allInstances = Collections.newSetFromMap(new WeakHashMap<BotServer, Boolean>());		private static TestClient testClient = null;		Socket client;	final Holdem holdemSession;	long lastCommandTimestamp;	int numPlayers = 0;	int heroSeat = -1;	MaverickGameInfo gInfo;	volatile boolean processingOn = true;	private final List<String> externalMessages = new ArrayList<String>(); 	private Agent [] agent;	private Agent [] streetAgent;	private float [] weight;	private boolean [] won = new boolean[MOVING_AVERAGE_PERIOD];	private int [][] aggressiveness;	private int hands = 0;	private final BufferedWriter out;	private final BufferedReader in;	private int toAct, nextToAct;	private DecisionBot bot = null;	private boolean echoMessages = Preferences.UI_ECHOMESSAGES.isOn();		public BotServer(Socket s, BufferedReader i, BufferedWriter o,			Agent[] agents, Agent[] streetAgents, Holdem holdem) {		agent = agents;		streetAgent = streetAgents;		weight = new float[agent.length];		for (int w = 0; w < weight.length; w++)			weight[w] = 1;		aggressiveness = new int[MOVING_AVERAGE_PERIOD][agent.length];		client = s;		holdemSession = holdem;		in = i;		out = o;		lastCommandTimestamp = System.currentTimeMillis();	}	private void stageEvent() {//		holdemSession.handGameSnapshot.onRoundStart(gInfo);		holdemSession.gameSnapshot.onRoundStart(gInfo);		if (holdemSession.gameObserver != null)			holdemSession.gameObserver.stageEvent (gInfo.getStage());		for (int a = 0; a < agent.length; a++)			if (agent[a] != null) 				agent[a].stageEvent(gInfo.getStage());			}		private void preActionEvent (int pos, Action act) throws AbortException {		if (! act.isBlind()) {			char action = GameAdapter.getAction(act);			String player = gInfo.getPlayerName(nextToAct);			holdemSession.gameSnapshot.update(gInfo);			if (DEBUG)				holdemSession.println(holdemSession.gameSnapshot.toString());			try {				if (Holdem.modeller.isOpen(player)) {					Holdem.histogramActions.addPoint(player, holdemSession.gameSnapshot, action, null);					Holdem.modeller.addData (player, Holdem.BEHAVIORAL_MODEL_ACTION, holdemSession.gameSnapshot, action);				}				if (ExpertGame.modeller.isOpen(player)) {					ExpertGame.modeller.addData (player, ExpertModel.Action, bot, action);					double pending = ExpertGame.modeller.adjustHoleProbability(player, gInfo, action);					holdemSession.println("ExpertEstimator load: "+pending);				}			} finally {//				holdemSession.handGameSnapshot.onAction(gInfo, action);				holdemSession.gameSnapshot.onAction(gInfo, action);			}		}	}		private void postActionEvent (int pos, Action act) {		Action paaction = gInfo.fromTotalToDeltaAmounts(act);		// A = amount due to call, B = amount to call/raise to		if (holdemSession.gameObserver != null)			holdemSession.gameObserver.actionEvent (pos, paaction);				// A = amount due to call, B = amount to raise on top of A		for (int a = 0; a < agent.length; a++)			if (agent[a] != null) 				agent[a].actionEvent(pos, act);	}	void gameOverEvent() {		if (bot != null) {			bot.shutdown();			bot = null;		}		if (gInfo != null) {			gInfo.gameOver();			if ((gInfo.getWinners() != null) && (heroSeat > -1)) {				won[hands % MOVING_AVERAGE_PERIOD] = gInfo.getWinners().contains(gInfo.getPlayerName(heroSeat));				String heroWon;				if (won[hands % MOVING_AVERAGE_PERIOD])					heroWon = gInfo.getPlayerName(heroSeat)+" won "+ (int) gInfo.getPlayer(heroSeat).getNetGain();				else					heroWon = gInfo.getPlayerName(heroSeat)+" lost "+ (int) gInfo.getPlayer(heroSeat).getAmountInPot();				holdemSession.println (heroWon);				holdemSession.println ("Winner(s): " + gInfo.getWinners());				int [] totalScore = new int[agent.length];				hands++;				int tg = Math.min(hands, MOVING_AVERAGE_PERIOD);				for (int g = 0; g < tg; g++)					for (int a = 0; a < agent.length; a++)						if (agent[a] != null) 							totalScore[a] += aggressiveness[g][a] * (won[g] ? 1 : -1);				int minScore = Integer.MAX_VALUE, maxScore = Integer.MIN_VALUE;				for (int a = 0; a < agent.length; a++) {					if (agent[a] != null) {						if (totalScore[a] < minScore) {							minScore = totalScore[a];						}						if (totalScore[a] > maxScore) {							maxScore = totalScore[a];						}					}				}				for (int a = 0; a < agent.length; a++) {					if (agent[a] != null) { 						if (minScore == maxScore)							weight[a] = 1;						else							weight[a] = (totalScore[a] - minScore) * SUCCESS_WEIGHT_FACTOR / (maxScore - minScore) + SUCCESS_WEIGHT_FACTOR;						holdemSession.println ("Weight for "+agent[a].getId()+" = "+weight[a]);					}				}			}			if (holdemSession.gameObserver != null) {				holdemSession.gameObserver.gameOverEvent ();				PaObserver.deleteInstance (gInfo);				holdemSession.gameObserver = null;			}			for (int a = 0; a < agent.length; a++)				if (agent[a] != null) 					agent[a].gameOverEvent();			if (holdemSession.gameObserver != null)				holdemSession.gameObserver.persist();			if ((gInfo.getGameID() % MODEL_PERSISTENCE_PERIOD) == 0) {				Holdem.histogramActions.persist();				ExpertGame.modeller.persist();//				Holdem.histogramHands.persist();//				Holdem.modeller.persist();			}		}	}	@Override	public void run() {		Hand h;		int amnt,i,who;		String msg;		out (Iface.MSG_NO_ACTION);		try {			while (client != null) {				msg = in.readLine();				lastCommandTimestamp = System.currentTimeMillis();				if (msg == null) {					msg = Iface.QUIT;				}				if (DEBUG)					if (gInfo != null)						holdemSession.println("Current pot: "+(int) gInfo.getTotalPotSize());				if (echoMessages || (! msg.startsWith(Iface.CMD_CHATTER)))						holdemSession.println(INPUT_PREFIX+msg);				String[] token = msg.split(" ");				if ((token != null) && (token.length > 0) && (						processingOn || 						msg.equalsIgnoreCase(Iface.QUIT) ||						msg.startsWith(Iface.CMD_CHATTER))) {										token[0] = token[0].toUpperCase();										if (Iface.QUIT.equals(token[0])) {						// QUIT						holdemSession.println("See you later...");						gameOverEvent();						if (testClient != null) {							Holdem.histogramActions.persist();							ExpertGame.modeller.persist();//							Holdem.histogramHands.persist();//							Holdem.modeller.persist();							Holdem.histogramActions.forEach(playerModeller -> {								playerModeller.persist();								return true;							});							System.exit(0);						}						return;					} else if (Iface.CMD_CHATTER.equals(token[0])) {		// FROM whom text						try {							if (Iface.TOKEN_FRONTEND.equals(token[1])) {								if (Iface.TOKEN_UNKNOWN_NAME.equals(token[2])) {		// FROM FRONTEND PLAYERNAME i name-i									if (gInfo != null) {										int player = Integer.valueOf(token[3]);										gInfo.getPlayer(player).setName(token[4]);										if (holdemSession.gameObserver != null)											holdemSession.gameObserver.setNewPlayer(gInfo.getPlayerName(player));										for (int a = 0; a < agent.length; a++)											if (agent[a] != null) {												if ((agent[a].capabilities().supported(Capabilities.BEHAVIORAL_MODELLING)) ||														(Preferences.MODEL_FULL.isOn()))													Holdem.modeller.setModelling(token[4], true);												if ((agent[a].capabilities().supported(Capabilities.EXPERT_MODELLING) ||														(Preferences.MODEL_FULL.isOn())) &&	(player != heroSeat))													ExpertGame.modeller.setModelling(token[4], true);												agent[a].playerUpdate(player);											}									}								} else {												// FROM FRONTEND messagetohopper									synchronized (HopperIface.instanceLock) {										HopperIface hopper = HopperIface.getInstance();										if (hopper != null) {											String message = Iface.externalMessage(													Iface.CMD_CHATTER + " " + holdemSession.toString() , token, 2);											synchronized (hopper.externalMessages) {												hopper.externalMessages.add(message);											}										}									}								}							} else if (Iface.TOKEN_CHATTER.equals(token[1])) {			// FROM CHAT chatmessage								while ((token[2].contains("won") || token[2].contains("wins")) &&										token[2].contains("#") &&										(token[2].contains(")") || token[2].contains(":"))) {									int ht = token[2].indexOf("#");									int hdt = token[2].indexOf(")", ht);									if (hdt == -1)										hdt = token[2].indexOf(":", ht);									int wt = token[2].indexOf("won", hdt);									int ewt = wt + 2;									if (wt == -1) {										wt = token[2].indexOf("wins", hdt);										ewt = wt + 3;									}									int nn = ewt + 1;									int tl = token[2].length();									while ((nn < tl) && (CURRENCY_CHARS.contains(token[2].subSequence(nn, nn + 1))))										nn++;									String player = token[2].substring(hdt + 1, wt);									String amount = token[2].substring(ewt + 1, nn);									if ((amount.charAt		(0) == '$') || (amount.charAt(0) == EURO))										amount = amount.substring(1);									if (amount.charAt(0) == CENT)										amount = "0." + (amount.length() == 2 ? "0" : "") + amount.substring(1);									if (amount.charAt(amount.length() - 1) == CENT)										amount = "0." + (amount.length() == 2 ? "0" : "") + 												amount.substring(0, amount.length() - 1);									int amwon = (int) (Double.valueOf(amount) * 100);									if (gInfo != null) {										int p;										for (p = 0; p < gInfo.getNumPlayers(); p++)											if (LevenshteinMap.equal(gInfo.getPlayerName(p), player)) {												gInfo.getPlayer(p).win(amwon);												gInfo.addWinner(gInfo.getPlayerName(p));												if (holdemSession.gameObserver != null)													holdemSession.gameObserver.winEvent(p, amwon, null);												for (int a = 0; a < agent.length; a++)													if (agent[a] != null) 														agent[a].winEvent (p, amwon, null);												holdemSession.println ("Win info from chatbox: " + player + " won " + amwon);												break;											}										if (p == gInfo.getNumPlayers())											holdemSession.println ("Player " + player + " could not be found in current game, dropped.");									}								token[2] = token[2].substring(nn);								}							} else {								send (Iface.MSG_WARNING_UNEXPECTED_MESSAGE);							}						} catch (Exception e) {							send(Iface.MSG_WARNING + " " + e);						}						send(Iface.MSG_NO_ACTION);					} else if (Iface.PING.equals(token[0])) {				// PING						send (Iface.PONG);						holdemSession.println("[PING]");					} else if (Iface.CMD_START_NEW_GAME.equals(token[0])) {	// NEWGAME bigblind numseats button game#						try {												// <name-i bankroll-i>...							gInfo = new MaverickGameInfo();							int bigblind = Integer.valueOf(token[1]);							gInfo.setBigBlind(bigblind);							numPlayers = Integer.valueOf(token[2]);							int button = Integer.valueOf(token[3]);							heroSeat = -1;							for (i=0;i<numPlayers;i++) {																String name = token[5+i*2];								int bankroll = Integer.valueOf(token[6+i*2]);								gInfo.addPlayer(name,gInfo.getLogDirectory()+name+".dat");								gInfo.getPlayer(name).setBankRoll(bankroll);							}							long gID = Long.valueOf(token[4]);							gInfo.startNewGame(gID);							holdemSession.println();							holdemSession.println("Starting game " + gInfo.getGameID()+ " (hand " + gID + ")"); 							gInfo.setButton(button);							gInfo.setCurrentPlayerPosition((numPlayers == 2) ? button : (button + 1) % numPlayers);							toAct = gInfo.getNumActivePlayers();							nextToAct = gInfo.getCurrentPlayerSeat();							printTable();							if (bot != null) {								System.err.println("Warning: BotServer.bot overwritten");								bot.shutdown();								bot = null;							}							bot = new DecisionBot(gInfo, true);							holdemSession.gameObserver = PaObserver.newInstance (agent, gInfo);							if (holdemSession.gameObserver != null)								holdemSession.gameObserver.gameStartEvent (gInfo);							for (int a = 0; a < agent.length; a++) 								if (agent[a] != null) {									agent[a].gameStartEvent(gInfo);									agent[a].setEconomyMode(false);									aggressiveness[hands % MOVING_AVERAGE_PERIOD][a] = 0;									if ((agent[a].capabilities().supported(Capabilities.BEHAVIORAL_MODELLING)) ||											(Preferences.MODEL_FULL.isOn()))										for (int p = 0; p < numPlayers; p++)											Holdem.modeller.setModelling(gInfo.getPlayerName(p), true);									if ((agent[a].capabilities().supported(Capabilities.EXPERT_MODELLING)) ||											(Preferences.MODEL_FULL.isOn())) {										for (int p = 0; p < numPlayers; p++)											ExpertGame.modeller.setModelling(gInfo.getPlayerName(p), true);									}								}//							holdemSession.handGameSnapshot = Holdem.newHandAdapter(DEBUG);//							holdemSession.handGameSnapshot.onRoundStart(gInfo);							holdemSession.gameSnapshot = Holdem.newActionAdapter(DEBUG);							holdemSession.gameSnapshot.onRoundStart(gInfo);														send(Iface.MSG_NO_ACTION);						} catch (Exception e) {							gameOverEvent();							send(Iface.MSG_ERROR + " " + e);						}					} else if (Iface.CMD_HOLE_CARDS.equals(token[0])) {		// DEAL seat holecards						try {							int seat = Integer.valueOf(token[1]); 							String player = gInfo.getPlayerName(seat);							String[] t = msg.split(" ", 3);							h = new Hand(t[2]);							gInfo.getPlayer(seat).revealHand(h.getCard(1), h.getCard(2));							StringBuilder hand = new StringBuilder("     ").append(player).append(":  ").append(h.toString());							if ((heroSeat == -1) && (gInfo.getStage() == Holdem.PREFLOP)) {								heroSeat = seat;								if (holdemSession.gameObserver != null)									holdemSession.gameObserver.dealHoleCardsEvent();								for (int a = 0; a < agent.length; a++) 									if (agent[a] != null) {										agent[a].dealHoleCardsEvent();										agent[a].holeCards (h.getCard(1), h.getCard(2), seat);									}								bot.holeCards(h.getCard(1), h.getCard(2), seat);							} else {								gInfo.setCurrentPlayerPosition(seat);								holdemSession.gameSnapshot.update(gInfo);//								holdemSession.gameSnapshot.hole[GameAdapter.playerToSeat(gInfo, seat)] = hole;//								Holdem.histogramHands.addPoint(player, holdemSession.gameSnapshot, GameAdapter.ACTION_NA);								if (Holdem.modeller.isOpen(player))									Holdem.modeller.addData (player, Holdem.BEHAVIORAL_MODEL_HAND, holdemSession.gameSnapshot, GameAdapter.ACTION_NA);								if (ExpertGame.modeller.isOpen(player))									ExpertGame.modeller.addData (player, ExpertModel.Hand, bot, GameAdapter.ACTION_NA);								if (DEBUG) {									((BNGameAdapter) holdemSession.gameSnapshot).calculateHandBuckets();									holdemSession.println(holdemSession.gameSnapshot.toString());								}								if (holdemSession.gameObserver != null)									holdemSession.gameObserver.showdownEvent (seat, h.getCard(1), h.getCard(2));								for (int a = 0; a < agent.length; a++)									if (agent[a] != null) 										agent[a].showdownEvent(seat, h.getCard(1), h.getCard(2));								hand.append(" (HR=").append(Bucket.evaluator.handRank(GameAdapter.handToEvaluate(h, gInfo.getBoard()))).										append(')');							}							holdemSession.println(hand.toString());							send(Iface.MSG_NO_ACTION);						} catch (Exception e) {							gameOverEvent();							send(Iface.MSG_ERROR + " " + e);						}					} else if (Iface.CMD_FLOP.equals(token[0])) {			// FLOP communitycards						try {							h = new Hand(msg.split(" ", 2)[1]);							toAct = gInfo.getNumActivePlayers();														gInfo.flop(h.getCard(1),h.getCard(2),h.getCard(3));	  							stageEvent();													gInfo.setCurrentPlayerPosition(gInfo.getButtonSeat());							selectNextToAct();							send(Iface.MSG_NO_ACTION);						} catch (Exception e) {							gameOverEvent();							send(Iface.MSG_ERROR + " " + e);						}					} else if (Iface.CMD_TURN.equals(token[0])) {			// TURN communitycards						try {							h = new Hand(msg.split(" ", 2)[1]);							toAct = gInfo.getNumActivePlayers();														gInfo.turn(h.getCard(1));	  							stageEvent();													gInfo.setCurrentPlayerPosition(gInfo.getButtonSeat());							selectNextToAct();							send(Iface.MSG_NO_ACTION);						} catch (Exception e) {							gameOverEvent();							send(Iface.MSG_ERROR + " " + e);						}					} else if (Iface.CMD_RIVER.equals(token[0])) {			// RIVER communitycards						try {							h = new Hand(msg.split(" ", 2)[1]);							toAct = gInfo.getNumActivePlayers();														gInfo.river(h.getCard(1));	  							stageEvent();													gInfo.setCurrentPlayerPosition(gInfo.getButtonSeat());							selectNextToAct();							send(Iface.MSG_NO_ACTION);						} catch (Exception e) {							gameOverEvent();							send(Iface.MSG_ERROR + " " + e);						}								} else if (Iface.CMD_NEXT_TO_ACT.equals(token[0])) {	// ACTION? seat						try {							nextToAct = Integer.valueOf(token[1]);							if (nextToAct != gInfo.getCurrentPlayerSeat()) 								outOfSync (nextToAct, gInfo.getCurrentPlayerSeat());							act();						} catch (Exception e) {							send(Iface.MSG_ERROR + " " + e);						}									} else if (Iface.CMD_BLIND.equals(token[0])) {			// BLIND seat amount						try {							who = Integer.valueOf(token[1]);							amnt = Integer.valueOf(token[2]);							gInfo.setCurrentPlayerPosition(who);							Action action;							if (amnt == gInfo.getBigBlindSize()) {								holdemSession.println("Big blind");								action = Action.bigBlindAction(amnt);								preActionEvent (who, action);								gInfo.bigBlind();							} else {								gInfo.setSmallBlind(amnt);								holdemSession.println("Small blind");								action = Action.smallBlindAction(amnt);								preActionEvent (who, action);								gInfo.smallBlind();							}							postActionEvent(who, action);								selectNextToAct ();						} catch (Exception e) {							send(Iface.MSG_WARNING + " " + e);						}						send(Iface.MSG_NO_ACTION);									} else if (Iface.FOLD.equals(token[0])) {				// FOLD seat						try {							who = Integer.valueOf(token[1]);							Action action = Action.foldAction(gInfo);							if (who != nextToAct) 								outOfSync (who, nextToAct);							preActionEvent (who, action);							toAct--;							boolean finished = gInfo.fold();							postActionEvent(who, action);							selectNextToAct();							if ((finished)/* && (gInfo.getStage() < Holdem.RIVER)*/) {								MaverickPlayerInfo player = gInfo.getPlayer(nextToAct); 								player.win((int) gInfo.getTotalPotSize());								gInfo.addWinner(player.getName());								gameOverEvent();								send(Iface.MSG_WARNING_GAME_OVER);							}						} catch (Exception e) {							send(Iface.MSG_WARNING + " " + e);						}						send(Iface.MSG_NO_ACTION);									} else if (Iface.CALL.equals(token[0])) {				// CALL seat amount						try {							who = Integer.valueOf(token[1]);							if (who != nextToAct) 								outOfSync (who, nextToAct);							amnt = Integer.valueOf(token[2]);							Action action = Iface.checkOrCall(gInfo, amnt);							preActionEvent (who, action);							toAct--;							gInfo.call();							postActionEvent(who, action);							selectNextToAct();						} catch (Exception e) {							send(Iface.MSG_WARNING + " " + e);						}						send(Iface.MSG_NO_ACTION);									} else if (Iface.RAISE.equals(token[0])) {				// RAISE seat amount						try {							who = Integer.valueOf(token[1]);							if (who != nextToAct) 								outOfSync (who, nextToAct);							amnt = Integer.valueOf(token[2]);							Action action = Iface.betOrRaise(gInfo, amnt);							toAct = gInfo.getNumActivePlayers()-1;							preActionEvent (who, action);							gInfo.raise();							postActionEvent(who, action);													selectNextToAct();						} catch (Exception e) {							send(Iface.MSG_WARNING + " " + e);						}						send(Iface.MSG_NO_ACTION);								} else if (Iface.CMD_WINNERS.equals(token[0])) {		// WINNER [numseats <seat-i amount-i>...]						try {							int numwin = 0;							int winningHr = -1;							if (token.length == 1) {								int[] winplayer = new int[gInfo.getNumActivePlayers()];								winplayer[0] = -1;								for (int p = 0; p < gInfo.getNumPlayers(); p++)									if (gInfo.isActive(p)) {										Hand hole = gInfo.getPlayer(p).getRevealedHand();										if (hole != null) {											int hr = Bucket.evaluator.handRank(GameAdapter.handToEvaluate(hole, gInfo.getBoard()));											if (hr > winningHr) {												winningHr = hr;												numwin = 1;												winplayer[numwin-1] = p;											} else if (hr == winningHr) {												numwin++;												winplayer[numwin-1] = p;											}										}									}								token = new String[numwin * 2 + 2];								for (int w = 0; w < numwin; w++) {									token[2+w*2] = String.valueOf(winplayer[w]);									token[3+w*2] = String.valueOf((int) (gInfo.getTotalPotSize() / numwin));								}							} else								numwin = Integer.valueOf(token[1]);							if ((numwin > 0) && (gInfo.isActive(heroSeat))) {								gInfo.setCurrentPlayerPosition(heroSeat);								holdemSession.gameSnapshot.update(gInfo);//								Holdem.histogramHands.addPoint(gInfo.getPlayerName(heroSeat), holdemSession.handGameSnapshot, //										GameAdapter.ACTION_NA);								String player = gInfo.getPlayerName(heroSeat);								if (Holdem.modeller.isOpen(player))									Holdem.modeller.addData (player, Holdem.BEHAVIORAL_MODEL_HAND, 											holdemSession.gameSnapshot, GameAdapter.ACTION_NA);								if (ExpertGame.modeller.isOpen(player))									ExpertGame.modeller.addData (player, ExpertModel.Hand, bot, GameAdapter.ACTION_NA);								if (DEBUG) {									((BNGameAdapter) holdemSession.gameSnapshot).calculateHandBuckets();									holdemSession.println(holdemSession.gameSnapshot.toString());								}							}							for (i=0;i<numwin;i++) {								who = Integer.valueOf(token[2+i*2]);								amnt = Integer.valueOf(token[3+i*2]);								MaverickPlayerInfo player = gInfo.getPlayer(who);								gInfo.addWinner(player.getName());								player.win(amnt);								String hs = "";								Hand rhand = gInfo.getPlayer(who).getRevealedHand();								if (rhand != null)									hs = rhand.toString();								if (holdemSession.gameObserver != null)									holdemSession.gameObserver.winEvent(who, amnt, hs);								for (int a = 0; a < agent.length; a++) 									if (agent[a] != null)										agent[a].winEvent(who, amnt, hs);								Hand hole = player.getRevealedHand();								if (hole != null) {									winningHr = Bucket.evaluator.handRank(GameAdapter.handToEvaluate(hole, gInfo.getBoard()));									Hand hand = new Hand ((new StringBuilder(hole.getCard(1).toString()).append(" ").append(hole.getCard(2).toString()).											append(" ").append(gInfo.getBoard().getCard(1).toString()).											append(" ").append(gInfo.getBoard().getCard(2).toString()).											append(" ").append(gInfo.getBoard().getCard(3).toString()).											append(" ").append(gInfo.getBoard().getCard(4).toString()).											append(" ").append(gInfo.getBoard().getCard(5).toString()).toString()));									holdemSession.println(new StringBuilder("Player ").append(player.getName()).											append(" won ").append(amnt).append(" with ").append(HandEvaluator.nameHand(hand)).											append(" (HR=").append(winningHr).append(")").toString());								} else if (HandHistoryParser.instance.isActive()) {									holdemSession.println("Misscraped cards for winner "+player.getName()+", will try to retrieve hand from hand history");									gInfo.setCurrentPlayerPosition(who);									holdemSession.gameSnapshot.update(gInfo);									holdemSession.cacheMuckedHand (gInfo.getHandNumber(), player.getName(),											Holdem.newHandAdapter(holdemSession.gameSnapshot, gInfo));									if (DEBUG)										holdemSession.println(holdemSession.gameSnapshot.toString());								} else									holdemSession.println("Warning: misscraping detected, unknown cards for winner "+player.getName());							}							for (int p = 0; p < gInfo.getNumPlayers(); p++)								if (gInfo.isActive(p)) {									Hand hole = gInfo.getPlayer(p).getRevealedHand();									String player = gInfo.getPlayerName(p);									if (hole == null) {										if (HandHistoryParser.instance.isActive()) {											holdemSession.println(player+" mucked, will try to retrieve hand from hand history");											gInfo.setCurrentPlayerPosition(p);											holdemSession.gameSnapshot.update(gInfo);											holdemSession.cacheMuckedHand (gInfo.getHandNumber(), player,													Holdem.newHandAdapter(holdemSession.gameSnapshot, gInfo));											if (DEBUG)												holdemSession.println(holdemSession.gameSnapshot.toString());/*										} else if (winningHr != -1) {											List<MLData> handEstimation = new ArrayList<>();																						int hr = ExploitGame.estimateHR(player, handEstimation, 0);											if (hr >= winningHr)												hr = winningHr - 1;											holdemSession.println(player+" mucked, assuming HR="+hr);											gInfo.setCurrentPlayerPosition(p);											holdemSession.gameSnapshot.update(gInfo);											holdemSession.gameSnapshot.precalculatedHandrank = hr;											if (DEBUG)												holdemSession.println(holdemSession.gameSnapshot.toString());//											Holdem.histogramHands.addPoint(player, holdemSession.handGameSnapshot, GameAdapter.ACTION_NA);											Holdem.modeller.addData (player, Holdem.BEHAVIORAL_MODEL_HAND, 													holdemSession.gameSnapshot, GameAdapter.ACTION_NA);											if (expertModelling)												ExpertGame.modeller.addData (player, ExpertModel.Hand, bot, GameAdapter.ACTION_NA);*/										}									}								}						} catch (Exception e) {							holdemSession.println(e.toString());						} finally {							gameOverEvent ();							gInfo = null;							send(Iface.MSG_NO_ACTION);						}						} else {						send(Iface.MSG_WARNING + " " + msg + "?"); 						send(Iface.MSG_NO_ACTION);					} 				} else if (! processingOn) {					holdemSession.println("Ignored: "+msg);					send(Iface.MSG_NO_ACTION);				}			}		} catch (Exception e) {			e.printStackTrace();			send(Iface.MSG_ERROR + " " + e);			send (Iface.QUIT);		} finally {			Holdem.histogramActions.persist();			ExpertGame.modeller.persist();//			Holdem.histogramHands.persist();//			Holdem.modeller.persist();			Holdem.histogramActions.forEach(playerModeller -> {				playerModeller.persist();				return true;			});			if (client != null)				try {					client.close();				} catch (IOException e) {					;				} 			client = null;			holdemSession.println("Session closed.");		}	}	private void selectNextToAct() {		gInfo.advanceCurrentPlayer();		nextToAct = gInfo.getCurrentPlayerSeat();		if (holdemSession.gameObserver != null)			holdemSession.gameObserver.gameStateChanged();		for (int a = 0; a < agent.length; a++)			if (agent[a] != null) 				agent[a].gameStateChanged();	}	private void act () {		if (gInfo.getCurrentPlayerSeat() == heroSeat) {			if (toAct <= 0) {				send(Iface.MSG_WARNING_NO_MORE_MOVES);			}			if (gInfo.getStage() == Holdem.PREFLOP) {				if (gInfo.getTotalPotSize() < gInfo.getBetSize()) {					send (Iface.MSG_NO_ACTION);					return;				}			}			Action action;			float [] decision = new float[3];			Action [] anAction = new Action[3];			Action streetAction = null;			for (int a = 0; a < agent.length; a++) 				if (agent[a] != null) {					Capabilities cap = agent[a].capabilities();					if ((gInfo.getNumPlayers() <= cap.maxPlayers) && (gInfo.getNumPlayers() >= cap.minPlayers)) {						action = agent[a].getAction();						if (streetAgent[gInfo.getStage()] == agent[a]) {							streetAction = action;							if (action != null)								holdemSession.println ("-- Preferred action for the street:");						}						holdemSession.println ("-> " + agent[a].getId() + " suggests: " + Iface.action(action));						if (action == null) {							;						} else if (action.isFold()) {							aggressiveness[hands % MOVING_AVERAGE_PERIOD][a]--;							decision[DECISION_FOLD] += weight[a];							anAction[DECISION_FOLD] = action;						} else if (action.isBetOrRaise()) {							aggressiveness[hands % MOVING_AVERAGE_PERIOD][a]++;							decision[DECISION_RAISE] += weight[a];							anAction[DECISION_RAISE] = action;						} else if (action.isCheckOrCall()) {							decision[DECISION_CALL] += weight[a];							anAction[DECISION_CALL] = action;						}					}				}			holdemSession.println ("RAISE score = "+decision[DECISION_RAISE]);			holdemSession.println ("CALL score = "+decision[DECISION_CALL]);			holdemSession.println ("FOLD score = "+decision[DECISION_FOLD]);			if (streetAction != null)				send (Iface.action(streetAction));			else if ((decision[DECISION_RAISE] > decision[DECISION_CALL]) && (decision[DECISION_RAISE] >= decision[DECISION_FOLD]))				send (Iface.action(anAction[DECISION_RAISE]));			else if ((decision[DECISION_CALL] >= decision[DECISION_RAISE]) && (decision[DECISION_CALL] >= decision[DECISION_FOLD]))				send (Iface.action(anAction[DECISION_CALL]));			else if ((decision[DECISION_FOLD] > decision[DECISION_RAISE]) && (decision[DECISION_FOLD] > decision[DECISION_CALL]))				send (Iface.action(anAction[DECISION_FOLD]));			else {				for (int d = 0; d < decision.length; d++) {					holdemSession.println (Iface.action (anAction[d]));				}				throw new RuntimeException ("Could not select an action from any of the agents");			}		} else {			send(Iface.MSG_ERROR_UNKNOWN_HERO + " " + gInfo.getCurrentPlayerSeat() +					Iface.TOKEN_INSTEAD_OF + heroSeat);		}	}	private void out (String str) {		try {			if (echoMessages || (! str.startsWith(Iface.CMD_CHATTER)))				holdemSession.println(OUTPUT_PREFIX+str);			out.write(str + "\r\n");			out.flush();		} catch (IOException e) {			holdemSession.println(e.toString());		}	}		void externalMessage (String from, String[] token, int first) {		String message = Iface.externalMessage(from, token, first);			synchronized (externalMessages) {				if (! externalMessages.contains(message))					externalMessages.add(message);			}	}	private void send (String str) {		if (Iface.MSG_NO_ACTION.equals(str)) {			if (gInfo != null) { 				for (int p = 0; p < gInfo.getNumPlayers(); p++) {					if (gInfo.getPlayerName(p).length() == 1) {						out (new StringBuilder (Iface.MSG_FROM).append(" ").append(Iface.TOKEN_UNKNOWN_NAME).								append(" ").append(p).toString());					}				}			}			synchronized (externalMessages) {				for (String message : externalMessages) {					out (message);				}				if (externalMessages.size() > 0)					externalMessages.clear();			}		} else if ((str.startsWith(Iface.MSG_ERROR)) || (str.startsWith(Iface.MSG_WARNING))) {			synchronized (HopperIface.instanceLock) {				HopperIface hopper = HopperIface.getInstance();				if (hopper != null) {					String message = Iface.CMD_CHATTER + " " + holdemSession.toString() + " " + str;					synchronized (hopper.externalMessages) {						hopper.externalMessages.add(message);					}				}			}		}		out (str);	}	private void outOfSync (int current, int supposed) {		send(Iface.MSG_WARNING_OUT_OF_SYNC + " " + current + Iface.TOKEN_INSTEAD_OF + supposed);		gInfo.setCurrentPlayerPosition(current);	}	private void printTable() {		holdemSession.println();		holdemSession.println("--- NEW GAME --- " + gInfo.getGameID() + " ---");		for (int i=0;i<gInfo.getNumPlayers();i++) 			holdemSession.println((i==gInfo.getButtonSeat() ? ("B> ") : " > ") +					Reporter.pad(gInfo.getPlayerName(i), 14) + " " + (int) gInfo.getPlayer(i).getBankRoll() );		holdemSession.println("-----------------------");	}	static void printValidParameters () {		System.out.println ("Valid parameters are:");		for (Preferences p : Preferences.values())			System.out.println ("  " + p.toString());	}		static void invocationError (int error) {		System.out.print ("Invocation Error: ");		switch (error) {		case ERROR_SERVER_IO:			System.out.println ("Server IO failed");			break;		case ERROR_MANDATORY_ARGUMENTS_MISSING:			System.out.println ("Mandatory argument(s) missing");			break;		case ERROR_UNKNOWN_ARGUMENT:			System.out.println ("Unknown argument");			break;		case ERROR_OPTIONAL_ARGUMENTS_MISSING:			System.out.println ("Optional argument(s) missing");			break;		case ERROR_INVALID_MIX_OF_ARGUMENTS:			System.out.println ("Invalid mix of arguments");			break;		case ERROR_WRONG_ARGUMENT_FORMAT:			System.out.println ("Argument(s) have the wrong format");			break;		case ERROR_UNKNOWN_PARAMETER:			System.out.println ("Unknown parameter");			break;		default:			System.out.println ("An unknown error has occurred");			break;		}		System.out.println ();		System.out.println(USAGE);		System.out.println ();		for (Bots bot : Bots.values())			System.out.println("  "+bot.name()+": "+bot.description);		System.exit(error);	}		/**	 *	 Main entry point. 	 */	static public void main(String[] args) {		// **************************************************************************************//		String[] dummy = new String[] {		args = new String [] {	// TODO//				"-rake", "rake_888.txt", 				"-test", "4", "200", "0",				"-testopp", "0", "127.0.0.1:6790",				"-testopp", "1", "127.0.0.1:6790",				"-testopp", "2", "127.0.0.1:6790",//				"-testopp", "3", "127.0.0.1:6790",//				"-testopp", "4", "127.0.0.1:6790",//				"-p", "model_train",//				"-p", "model_full",				"-p", "model_path=E:\\Backups\\poker\\maverick\\data\\models",				"-p", "model_readonly",//				"-p", "sim_handtime=4000",//				"-p", "test_actiondelay=250",//				"-hh", "hh_ps.txt", "F:/poker/Temp/hh",				"6789"				, "simexpertbot"				, "jagbot"				, "preflop=jagbot", "flop=simexpertbot", "turn=simexpertbot", "river=simexpertbot"			};		// **************************************************************************************		System.out.println (VERSION);		System.out.println();		if (args.length > 1) {			int param = 0;			long seed = 0;			while ((args[param].charAt(0) == '-') && (param < args.length)) {				if (args[param].toLowerCase().equals("-test")) {					if (args.length < param + 3 + 3) 						invocationError (ERROR_OPTIONAL_ARGUMENTS_MISSING);					int players = Integer.valueOf(args[++param]);					int rounds = Integer.valueOf(args[++param]);					seed = Long.valueOf(args[++param]);					testClient = new TestClient (players, rounds);					TestClient.opponents = new String[players];				} else if (args[param].toLowerCase().equals("-rake")) {					if (args.length < param + 3 + 1)						invocationError (ERROR_OPTIONAL_ARGUMENTS_MISSING);					Raketable.instance.populate (args[++param]);					if (Raketable.instance.size == 0) {						System.err.println("Warning: failed to read rake table " + args[param]);					}				} else if (args[param].toLowerCase().equals("-hh")) {					if (args.length < param + 3 + 1)						invocationError (ERROR_OPTIONAL_ARGUMENTS_MISSING);					if (! HandHistoryParser.instance.init (args[++param]))						System.err.println("Warning: failed to initialize hand history parser using file format " + args[param]);					if (! HandHistoryParser.instance.setListeningPath (args[++param]))						System.err.println("Warning: failed to initialize hand history parser in path " + args[param]);				} else if (args[param].toLowerCase().equals("-testopp")) {					if (args.length < param + 3 + 2)						invocationError(ERROR_OPTIONAL_ARGUMENTS_MISSING);					if (TestClient.opponents == null)						invocationError(ERROR_INVALID_MIX_OF_ARGUMENTS);					int seat = Integer.valueOf(args[++param]);					String opponent = args[++param].toLowerCase();					if (! ((TestClient.ALWAYS_CALL_OPPONENT.equals(opponent)) || 							(TestClient.ALWAYS_RAISE_OPPONENT.equals(opponent)) ||							(TestClient.RANDOM_ACTION_OPPONENT.equals(opponent)) ||							(opponent.contains(":"))))						invocationError(ERROR_UNKNOWN_ARGUMENT);					TestClient.opponents[seat] = opponent;				} else if (args[param].toLowerCase().equals("-p")) {					if (args.length < param + 3 + 1) {						printValidParameters ();						invocationError (ERROR_OPTIONAL_ARGUMENTS_MISSING);					}					String kv = args[++param];					if (Preferences.add(kv) == null) {						printValidParameters ();						invocationError (ERROR_UNKNOWN_PARAMETER);					}				} else					invocationError(ERROR_UNKNOWN_ARGUMENT);				param++;			}			Preferences.ready = true;			ExpertGame.modeller = new ExpertModeller();			System.out.println("Maverick listening to port "+args[param]);			int port = Integer.valueOf(args[param]);			try {				@SuppressWarnings("resource")				ServerSocket serverSock = new ServerSocket(port, 5);				if (testClient != null) {					if (seed == 0)						seed = System.currentTimeMillis();					System.out.println("Seed used by random number generator: "+seed);					Holdem.RNG.setSeed(seed);					testClient.init();					testClient.connect (port);				}				while (true) {					Socket clientSock = serverSock.accept();					System.out.println("Accepted connection from " + clientSock.getInetAddress() + 							":" + clientSock.getPort());					BufferedWriter out = new BufferedWriter(new OutputStreamWriter(clientSock.getOutputStream()));					String hail = Iface.CMD_CHATTER + " " + VERSION;					out.write(hail + "\r\n");					out.flush();					System.out.println(OUTPUT_PREFIX + hail);					BufferedReader in = new BufferedReader(new InputStreamReader(clientSock.getInputStream(), "ISO-8859-1"));					String response = in.readLine();					Runnable server = null;					if (response.toUpperCase().startsWith(Iface.CMD_HOPPER)) {												server = new HopperIface (clientSock, in, out);						synchronized (HopperIface.instanceLock) {							HopperIface hopper = HopperIface.getInstance();							if (hopper != null) {								System.out.println ("Closing existing hopper connection");								hopper.client.close();							}							HopperIface.instance = new WeakReference<HopperIface>((HopperIface) server);						}						System.out.println ("#/ " + INPUT_PREFIX + response);					} else {						String[] token = response.split(" ");						Holdem holdem;						if (token.length >= 2)							holdem = new Holdem (token[1]);						else							holdem = new Holdem();						holdem.println(INPUT_PREFIX + response);						Agent[] agents = new Agent[Bots.COUNT];						Agent[] streetAgents = new Agent[4];						for (int a = param + 1; a < args.length; a++) {							String ag = args[a].toUpperCase();							int str = -1;							int eq = ag.indexOf('=');							if (eq > -1) {								String s = ag.substring(0, eq);								if (s.equals("PREFLOP"))									str = Holdem.PREFLOP;								else if (s.equals("FLOP"))									str = Holdem.FLOP;								else if (s.equals("TURN"))									str = Holdem.TURN;								else if (s.equals("RIVER"))									str = Holdem.RIVER;								else									invocationError (ERROR_UNKNOWN_PARAMETER);								ag = ag.substring(eq + 1);								System.out.println("Using "+ag+" for street "+s);							}							Agent agent = null;							if (ag.equals(Bots.FELLOMEN2.name())) {								if ((agent = agents[Bots.FELLOMEN2.ordinal()]) == null)									agent = agents[Bots.FELLOMEN2.ordinal()] = new FellOmen_2 (holdem);							} else if (ag.equals(Bots.EXPLOITBOT.name())) {								if ((agent = agents[Bots.EXPLOITBOT.ordinal()]) == null)									agent = agents[Bots.EXPLOITBOT.ordinal()] = new SimBot (holdem, new ExploitGame());							} else if (ag.equals(Bots.SIMEXPERTBOT.name())) {								if ((agent = agents[Bots.SIMEXPERTBOT.ordinal()]) == null)									agent = agents[Bots.SIMEXPERTBOT.ordinal()] = new SimBot (holdem, new ExpertGame());							} else if (ag.equals(Bots.POKIBOT.name())) {								if ((agent = agents[Bots.POKIBOT.ordinal()]) == null)									agent = agents[Bots.POKIBOT.ordinal()] = new Pokibot (holdem);							} else if (ag.equals(Bots.JAGBOT.name())) {								if ((agent = agents[Bots.JAGBOT.ordinal()]) == null)									agent = agents[Bots.JAGBOT.ordinal()] = new Jagbot (holdem);/*							} else if (ag.equals(Bots.MCTSBOT.name())) {								if ((agent = agents[Bots.MCTSBOT.ordinal()]) == null)									agent = agents[Bots.MCTSBOT.ordinal()] = new MCTSMeerkatBot ();*/							} else								invocationError(ERROR_UNKNOWN_ARGUMENT);							if (str > -1)								streetAgents[str] = agent;						}						server = new BotServer(clientSock, in, out, agents, streetAgents, holdem);						synchronized (allInstances) {							allInstances.add((BotServer) server);						}											}					new Thread(server).start();				}			} catch (IOException ex) {				invocationError(ERROR_SERVER_IO);			}		} else			invocationError(ERROR_MANDATORY_ARGUMENTS_MISSING);	}}