package poker;import java.lang.reflect.Field;import com.biotools.meerkat.Card;public class MaverickPlayerInfo extends com.biotools.poker.Q.F {		public static final char			SMALL_BLIND_ACTION	= 's';	public static final char			BIG_BLIND_ACTION	= 'B';	public static final char			RAISE_ACTION 		= 'r';	public static final char			BET_ACTION 			= 'b';	public static final char			CALL_ACTION 		= 'c';	public static final char			CHECK_ACTION 		= 'k';	public static final char			FOLD_ACTION 		= 'f';	public static final char			ROUND_DELIMITER		= '/';	private static final long serialVersionUID = 2054875498830170688L;		protected StringBuilder actions = null;	public MaverickPlayerInfo (String name, MaverickGameInfo ginfo) {		super (name, ginfo);	}		public MaverickPlayerInfo (MaverickPlayerInfo pInfo, MaverickGameInfo gInfo) {		super (pInfo, gInfo);		if (pInfo.actions != null)			actions = new StringBuilder (pInfo.actions);		else			actions = null;	}			public void setName (String name) {		try {			Field playersField = com.biotools.poker.Q.F.class.getDeclaredField("T");			playersField.setAccessible(true);			playersField.set((com.biotools.poker.Q.F) this, name);		} catch (Exception e) {			e.printStackTrace();		}	}		/**	 * Obtain the amount of bets the player had to call during	 * their last action.	 */	public int getLastBetsToCall() {		return (int) K();	}	/**	 * The bet ratio is the number of times a player bet divided by the	 * number of chances they had to bet (a measure of agressiveness)	 */	public double betRatio() {		int b=0,t=0;		String s = getActions();		for (int i=0;i<s.length();i++) {			if (s.charAt(i) != ROUND_DELIMITER) {				t++;				if (s.charAt(i) == RAISE_ACTION)					b++;			}		}		return (double)b/(double)t;	}	/** 	 * Have the player pay what it owes to the pot.	 * Note: Called only by Holdem.	 * @param owed The amount which the player should have in the pot (not necessarily what is owed)	 * @return The amount which the player has paid to the pot to owe nothing	 */	protected int pay(int owed) {		return (int) I (owed);	}		public void logFold() {		actions.append(FOLD_ACTION);//		E();	}	public void logCall(/*int betAmountPerRound*/) {		if (getAmountToCall() > 0)			actions.append(CALL_ACTION);		else 			actions.append(CHECK_ACTION);//		return (int) G (betAmountPerRound);	}	public void logRaise(/*int betAmountPerRound*/) {		actions.append(RAISE_ACTION);//		return (int) F (betAmountPerRound);	}	public void logBet(/*int betAmountPerRound*/) {		actions.append(BET_ACTION);//		return (int) B (betAmountPerRound);	}		public void logBigBlind() {		actions.append(BIG_BLIND_ACTION);//		F();	}	public void logSmallBlind() {		actions.append(SMALL_BLIND_ACTION);//		F();	}	/**	 * The betting round is over	 */	public void logAdvanceStage() {		actions.append(ROUND_DELIMITER);//		D();	}	/**	 * Obtain a string representation of the player's actions.	 * Ex: crc/rc/cf  c = check/call, r = bet/raise, f = fold, / = end of betting	 * @return String of actions	 */	public String getActions() {		if (actions == null)			return "";		return actions.toString();	}	/**	 * Determine the amount a player must pay to stay in the game	 * @param amount_needed the total amount the player should have in the pot	 * @return the amount needed to stay in.	 */	public double getAmountToCall(int amount_needed) {		return amount_needed - getAmountInPot();	}	/**	 * Reveal the hole cards in a showdown	 * @param c1 the first card	 * @param c2 the second card	 */	public void revealHand(Card c1, Card c2) {		A (c1, c2);	}	/**	 * Start a new game with this player	 */	public void startNewGame() {		actions = new StringBuilder ();//		D (true);	}	public void setBankRoll(int bankroll) {		E (bankroll);	}	/**	 * Give the player some money	 * @param amount the amount of money to give	 */	public void win(int amount) {		H (amount);	}	}